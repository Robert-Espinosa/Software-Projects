
import java.io.Serializable;
import java.util.Comparator;

import components.map.Map;
import components.map.Map1L;
import components.queue.Queue;
import components.queue.Queue1L;
import components.set.Set;
import components.set.Set1L;
import components.simplereader.SimpleReader;
import components.simplereader.SimpleReader1L;
import components.simplewriter.SimpleWriter;
import components.simplewriter.SimpleWriter1L;

/**
 * Put a short phrase describing the program here.
 *
 * @author Robbie Espinosa
 *
 */
public final class WordCounter {

    /**
     * Private constructor so this utility class cannot be instantiated.
     */
    private WordCounter() {
    }

    /**
     * Outputs the "opening" tags in the generated HTML file. These are the
     * expected elements generated by this method:
     *
     * @param out
     *            the output stream
     * @param name
     *            the name of the file
     * @updates out.content
     * @requires [the root of channel is a <channel> tag] and out.is_open
     * @ensures out.content = #out.content * [the HTML "opening" tags]
     */
    private static void outputHeader(SimpleWriter out, String name) {

        //Starts html file off by printing the name and beining a table
        out.println("<html>");
        out.println("<head>");
        out.println("<title>" + "WordCounter" + "</title>");
        out.println("</head>");
        out.println("<h1> Words Counted in " + name + "</h1>");

        out.println("<body>");
        out.print("<table border=\"1\">");

    }

    /**
     * Outputs the "opening" tags in the generated HTML file. These are the
     * expected elements generated by this method:
     *
     * @param out
     *            the output stream
     * @updates out.content
     * @requires [the root of channel is a <channel> tag] and out.is_open
     * @ensures out.content = #out.content * [the HTML "opening" tags]
     */
    private static void outputFooter(SimpleWriter out) {

        //prints final tags to complete html file
        out.print("</table>");
        out.println("</body>");
        out.println("</html>");

    }

    /**
     * Processes one news item and outputs one table row. The row contains three
     * elements: the publication date, the source, and the title (or
     * description) of the item.
     *
     * @param file
     *            the file name
     * @param s
     *            takes in a map of strings and integers to store the words and
     *            counts into
     * @updates out.content
     * @requires [the label of the root of item is an <item> tag] and
     *           out.is_open
     * @ensures <pre>
     * out.content = #out.content *
     *   [an HTML table row with publication date, source, and title of news item]
     * </pre>
     * @return returns the map after changing all values to words and count
     */
    private static Map<String, Integer> processItem(String file,
            Map<String, Integer> s) {
        SimpleReader input = new SimpleReader1L(file);
        Set<Character> q = new Set1L<Character>();

        //stared by making a set of "separators and spaces" to compare against
        // our word
        q.add(' ');
        q.add(',');
        q.add(':');
        q.add('.');
        q.add('?');
        q.add('-');
        q.add('{');
        q.add('(');
        q.add(';');
        q.add('|');
        q.add('}');
        q.add('"');
        q.add(')');
        q.add('!');

        String line, word;
        int position;
        //this is the main loop of the program going through each line of text
        while (!input.atEOS()) {
            //stores next line of text into string
            line = input.nextLine();
            position = 0;

            //we just want to continue until the line is over so we can reset
            //our position
            while (position < line.length()) {
                word = nextWordOrSeparator(line, position, q).toLowerCase();
                //this works perfectly because each time it pulls the word or
                //Separator the program updates its position thats know here
                position += word.length();

                //if its a space or separator we simply want to do nothing as
                // our index was increased and we are ready for the next word.
                if (!q.contains(word.charAt(0))) {
                    if (s.hasKey(word)) {
                        //made both to lower case because some first letters are
                        // capital
                        s.replaceValue(word, s.value(word) + 1);
                    } else {
                        s.add(word, 1);
                    }
                }
            }
        }

        input.close();
        return s;

    }

    /**
     *
     * @param text
     *            this is the line that we are on in the file
     * @param position
     *            the position needs to be changed each time so the method takes
     *            in the new position that its supposed to be at
     * @param separators
     *            list of character that are considered separators and that
     * @return the word or separator that can next after position;
     */
    private static String nextWordOrSeparator(String text, int position,
            Set<Character> separators) {
        assert text != null : "Violation of: text is not null";
        assert separators != null : "Violation of: separators is not null";
        assert 0 <= position : "Violation of: 0 <= position";
        assert position < text.length() : "Violation of: position < |text|";

        String remove = text.substring(position);
        char positionchar = remove.charAt(0);
        String tester = "";
        boolean isWord = !separators.contains(positionchar);
        boolean check = true;
        int i = 0;

        while (position + i < text.length() && check) {
            if (separators.contains(remove.charAt(i))) {
                if (!isWord) {
                    tester += remove.charAt(i);
                } else {
                    check = false;
                }
            } else {
                if (isWord) {
                    tester += remove.charAt(i);
                } else {
                    check = false;
                }
            }
            i++;
        }

        return tester;

    }

    /**
     *
     * @param out
     *            output stream that we are writing to. Html file
     * @param m
     *            map of all our values and keys
     * @param q
     *            q with all the same words as the map but alphabetized in in
     *            order to print
     */
    private static void printToFile(SimpleWriter out, Map<String, Integer> m,
            Queue<String> q) {

        //count from back of the queue because the queue resizes and you dequeue
        for (int i = q.length(); i > 0; i--) {
            String word = q.dequeue();
            //I simply take the word out of the queue and put it and its value
            //in the table using the tags below. I also just use the word from
            //the queue to find the value in the map.
            out.println("<tr>");
            out.println("   <td>" + word + "</td>");
            out.println("   <td>" + m.value(word) + "</td>");
            out.println("</tr>");
        }
    }

    /**
     *
     * @author espo2
     *
     *         in software one we used this method of alphabetizing. This made
     *         it so we have a class thats main job is just to compare two
     *         strings using a comparator
     *
     */
    private static class StringLT implements Comparator<String>, Serializable {
        /**
         * Originally i didn't include Serializable which gave me a spot bug
         * that got rid of with this.
         */
        private static final long serialVersionUID = -3063047826522802096L;

        @Override
        public int compare(String p1, String p2) {
            return p1.compareTo(p2);
        }
    }

    /**
     *
     * @param m
     *            map with all correct values
     * @param q
     *            queue that is empty and ready to store values
     */
    private static void alphabetize(Map<String, Integer> m, Queue<String> q) {
        Comparator<String> sorter = new StringLT();

        //for each pair in our map enqueue the string value
        for (Map.Pair<String, Integer> s : m) {
            q.enqueue(s.key());
        }
        q.sort(sorter);
    }

    /**
     * Main method.
     *
     * @param args
     *            the command line arguments
     */
    public static void main(String[] args) {
        SimpleReader input = new SimpleReader1L();
        SimpleWriter output = new SimpleWriter1L();

        Queue<String> q = new Queue1L<>();
        Map<String, Integer> wordMap = new Map1L<>();

        //asks for input and output files storing both names
        output.print("Please enter a valid text file: ");
        String file = input.nextLine();
        output.print("Please enter the name of new file: ");
        String out = input.nextLine();

        SimpleWriter writer = new SimpleWriter1L(out);

        //begin our HTML file with header
        outputHeader(writer, file);

        //store our new map into m and process the whole file
        Map<String, Integer> m = processItem(file, wordMap);

        //need to alphabetize them before printing. I do this by storing the words
        //into a queue and then sorting the queue and using the queues keys to
        //access their values and counts
        alphabetize(m, q);

        //finally print all my data to tables
        printToFile(writer, m, q);

        //closes html tags
        outputFooter(writer);

        input.close();
        output.close();
    }

}
