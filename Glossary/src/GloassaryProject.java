import components.map.Map;
import components.map.Map1L;
import components.sequence.Sequence;
import components.sequence.Sequence1L;
import components.set.Set;
import components.set.Set1L;
import components.simplereader.SimpleReader;
import components.simplereader.SimpleReader1L;
import components.simplewriter.SimpleWriter;
import components.simplewriter.SimpleWriter1L;

/**
 * Program to convert an XML RSS (version 2.0) feed from a given URL into the
 * corresponding HTML output file.
 *
 * @author Robbie Espinosa
 *
 */
public final class GloassaryProject {

    /**
     * Private constructor so this utility class cannot be instantiated.
     */
    private GloassaryProject() {
    }

    /**
     * given a spacific map sort this map and store it into sortend and tranfer
     * it back.
     *
     * @param s
     * @param map
     */
    public static void sort(Sequence<String> s, Map<String, String> map) {
        Sequence<String> sorted = new Sequence1L<String>();
        sorted.transferFrom(s);
        int count = 0;
        String holder = "";
        while (sorted.length() != 0) {
            int counter = 0;
            int secondCounter = 0;

            while (counter < sorted.length() - 1) {
                holder = sorted.entry(secondCounter);
                if (holder.compareTo(sorted.entry(counter + 1)) > 0) {
                    secondCounter = counter + 1;
                }
                counter++;
            }
            s.add(count, sorted.entry(secondCounter));
            sorted.remove(secondCounter);
            count++;
        }
        Map<String, String> newMap = new Map1L<String, String>();
        count = 0;
        //add each element back into the new map.
        while (count < s.length()) {
            newMap.add(s.entry(count), map.value(s.entry(count)));
            count++;
        }
        map.transferFrom(newMap);
    }

    /**
     *
     * @param strMap
     *            map that includes both definition and terms
     * @param in
     *            input string to read from
     * @return returns the
     */
    private static Sequence<String> generateTermsAndDefinitions(
            Map<String, String> strMap, SimpleReader in) {

        Sequence<String> q = new Sequence1L<>();
        int count = 0;
        while (!in.atEOS()) {
            //starts at top of text file and reads index word definition and checks
            String indexWord = in.nextLine();
            String definition = in.nextLine();
            String empty = in.nextLine();
            while (empty.trim().length() != 0) {
                definition = definition + empty;
                empty = in.nextLine();

            }

            strMap.add(indexWord, definition);
            q.add(count, indexWord);
            count++;
        }
        return q;
    }

    /**
     * get the next word in the definition and returns it.
     *
     * @param s
     *            is the whole definition string that needs to be split up
     * @param pos
     *            position in the whole definition to start from
     * @return returns the next word in defintion
     */
    public static String nextWord(String s, int pos) {

        String word = "";
        //looks for next word by using a boolean and seeing if theres a space
        int count = pos;
        boolean endOfWord = false;
        while (!endOfWord) {
            if (s.charAt(count) == ' ' || count == s.length() - 1) {
                endOfWord = true;
            }
            word += s.charAt(count);
            count++;
        }

        return word;
    }

    /**
     * Outputs the "opening" tags in the generated HTML file. These are the
     * expected elements generated by this method:
     *
     * @param out
     *            the output stream
     * @updates out.content
     * @requires [the root of channel is a <channel> tag] and out.is_open
     * @ensures out.content = #out.content * [the HTML "opening" tags]
     */
    private static void outputHeader(SimpleWriter out) {
        assert out != null : "Violation of: out is not null";
        assert out.isOpen() : "Violation of: out.is_open";

        //header to begin the html file.
        out.println("<html>");
        out.println("<head>");
        out.println("<title> sample glossary </title>");
        out.println("</head>");
        out.println("<body>");
        out.println("<h2>");
        out.println("Glossary");
        out.println("</h2>");
        out.println("<hr>");
        out.println("<h3>Index</h3>");
        out.println("<ul>");

    }

    /**
     * Generate links for different indexes. Begins by starting to make the
     * Different file names by getting them from the list.
     *
     *
     *
     *
     *
     * @param dictionary
     *
     * @param list
     * @param s
     */
    public static void generateLinks(Map<String, String> dictionary,
            Sequence<String> list, String s) {
        SimpleWriter out = new SimpleWriter1L();
        Set<Character> pun = new Set1L<>();
        pun.add(',');
        String fileName = "";
        for (int i = 0; i < list.length(); i++) {
            fileName = list.entry(i);

            SimpleWriter file = new SimpleWriter1L(
                    s + "/" + fileName + ".html");

            file.println("<html><head><title>");
            file.println(fileName + "</title></head><body>");
            file.println("<h2><b><i>");
            file.println("<font color = \"red\">" + fileName);
            file.println("</font></i></b></h2><hr>");
            file.println("<blockquote>");
            int position = 0;
            // generate link for each word that is in the map
            while (position < dictionary.value(fileName).length() - 1) {
                if (!containsWord(list,
                        nextWord(dictionary.value(fileName), position))
                                .equals("")) {
                    String linked = nextWord(dictionary.value(fileName),
                            position);
                    //had issue where I had extra space so I check for it here
                    // and delete it if it still has it.
                    if (linked.charAt(linked.length() - 1) == ' ') {
                        linked = linked.substring(0, linked.length() - 1);
                    }
                    file.println("<a href = \"" + linked + ".html\">" + linked
                            + "</a>");
                    position += linked.length();

                } else {
                    file.println(
                            nextWord(dictionary.value(fileName), position));
                    position += nextWord(dictionary.value(fileName), position)
                            .length();
                }

            }

            file.println("</blockquote><p>return to <a href = \""
                    + "index.html\">index</a>.</p>");
            file.println("</body>");
            file.println("</html>");

            file.close();
        }
    }

    /**
     *
     * @param list
     *            lincoming values for
     * @param s
     *            taking in parameter s to see if the word is in dictionary
     * @return returns a string of the word
     */
    public static String containsWord(Sequence<String> list, String s) {

        String word = "";
        for (int i = 0; i < list.length(); i++) {
            if (list.entry(i).equals(s)) {
                word = list.entry(i);
            }

        }

        if (s.substring(s.length() - 1).equals(" ")) {
            for (int q = 0; q < list.length(); q++) {
                if (list.entry(q).equals(s.substring(0, s.length() - 1))) {
                    word = s.substring(0, s.length() - 1);
                }

            }
        }

        return word;
    }

    /**
     * Main method.
     *
     * @param args
     *            the command line arguments; unused here
     */
    public static void main(String[] args) {
        SimpleReader inConsole = new SimpleReader1L();
        SimpleWriter outConsole = new SimpleWriter1L();

        /*
         * prompt user to enter url that will work
         */
        outConsole.print("Enter the Html file");
        String inputFile = inConsole.nextLine();

        outConsole.print(
                "Enter the folder to which you would like this to be output");
        String outputFolder = inConsole.nextLine();

        SimpleReader input = new SimpleReader1L(inputFile);
        SimpleWriter output = new SimpleWriter1L(outputFolder + "/index.html");

        Map<String, String> defintions = new Map1L<>();
        Sequence<String> terms = new Sequence1L<>();

        //extract terms and def
        terms.append(generateTermsAndDefinitions(defintions, input));

        //sort terms
        sort(terms, defintions);

        //modify links

        generateLinks(defintions, terms, outputFolder);

        outputHeader(output);

        //for each term generate its link in the file
        for (int i = 0; i < terms.length(); i++) {
            output.println("<li><a href=\"" + terms.entry(i) + ".html\">"
                    + terms.entry(i) + "</a></li>");
        }

        output.println("</ul>");
        output.println("</body>");
        output.println("</html>");

        inConsole.close();
        outConsole.close();
    }

}
